ArrayList<DustParticle> dust = new ArrayList<DustParticle>();


class Escena5 {  
  
  // Imagenes   
  PImage fondo5, viejo, reloj5, mesa5;
 

  // Posiciones
  float viejoX, mesa5X, reloj5X;
  float viejoY, mesa5Y, reloj5Y;
  
  // Audio
  AudioPlayer brisa, audio5, divinidad;
  
  //TRANSICION INICIO
  int rows = 140;
  float rowHeight;
  float[] windOffset;
  boolean[] activeRow;    // si la fila todavía se mueve y produce partículas

  int currentRow = 0;
  int rowDelay = 3;
  int lastRowFrame = 0;

  float windSpeed = 7; 
     
  boolean hoverReloj = false;

  float relojScale = 1.0;
  float relojScaleTarget = 1.0;
  float relojScaleSpeed = 0.1;

  boolean zoomReloj = false;
  float relojZoom = 1.0;
  float relojZoomSpeed = 0.35;   // rapidez del zoom



  Escena5() {
    
    //Posiciones
  viejoX= width/2;
  mesa5X= width/2; 
  reloj5X= width/2;
  viejoY= height/2+50;
  mesa5Y= height/2+500;
  reloj5Y= height/2+385;
     
  
   //TRANSICION INICIO
    rowHeight = height / float(rows);
    windOffset = new float[rows];
    activeRow = new boolean[rows];

    for (int i = 0; i < rows; i++) {
      windOffset[i] = 0;
      activeRow[i] = false;
    }
    
   activeRow[0] = true; // empezamos desde la primera fila
   
       // Audio
     //audio5 = audioManager.loadFile("esc5.mp3");
     //divinidad = audioManager.loadFile("dios.mp3");
      
       fondo5= loadResizedImage("fondotorre.png", width+100);
       viejo= loadResizedImage("viejo.png",1000);
       reloj5= loadResizedImage("r5.png",400);
       mesa5= loadResizedImage("mesa5.png",1100);

  }
  
  void dibujar(){
    //audio5.loop();     
    pushStyle();
    imageMode(CENTER);
    
    image(fondo5, width/2, height/2);
    

    //VIEJO
    image(viejo, viejoX, viejoY);
    
    //MESA
    image(mesa5, mesa5X, mesa5Y);   
    
    checkHoverReloj();
  
    if (hoverReloj) {
      cursor(HAND);
      relojScaleTarget = 1.05;
    } else {
      cursor(ARROW);
      relojScaleTarget = 1.0;
    }

  // interpolación suave
    relojScale = lerp(relojScale, relojScaleTarget, relojScaleSpeed);
   
   if (zoomReloj) {
    relojZoom += relojZoomSpeed;
  }

   
    // RELOJ
    pushMatrix();
    translate(reloj5X, reloj5Y);
    float escalaFinal = relojScale * relojZoom;
    scale(escalaFinal);

 pushStyle();
    if (hoverReloj) {
      tint(255, 220, 80);
    } else{
      noTint();
    }
    image(reloj5, 0, 0);
 popStyle();
  popMatrix();


    updateWind();
    drawSand();
    
    if (zoomReloj && relojZoom > 8) {
      //audio5.stop();
  estadoGeneral= ESCENA6;
   }

  }
  
 void updateWind() {
   //brisa.loop();
   
  // Activar filas progresivamente
  if (frameCount - lastRowFrame > rowDelay && currentRow < rows - 1) {
    currentRow++;
    activeRow[currentRow] = true;
    lastRowFrame = frameCount;
  }

  for (int i = 0; i <= currentRow; i++) {
    if (activeRow[i]) {

      float n = noise(i * 0.08, frameCount * 0.02);
      float wind = windSpeed * (0.4 + n);
      windOffset[i] += wind;

      // Generar partículas de polvo
      float y = i * rowHeight;
      float sandFrontX = width - windOffset[i];

      if (random(1) < 0.3) {
        dust.add(new DustParticle(
          sandFrontX,
          y + rowHeight * 0.5 + random(-4, 4), wind));
}

      if (windOffset[i] >= width) {
        windOffset[i] = width;
        activeRow[i] = false;
      }
    }
  }

  // Actualizar y dibujar partículas
  for (int i = dust.size() - 1; i >= 0; i--) {
    DustParticle p = dust.get(i);
    p.update();
    p.display();
    if (p.isDead()) {
      dust.remove(i);
    }
  }
  //brisa.stop();
}

void ratonPulsado() {
  if (hoverReloj && !zoomReloj && arenaTerminada()) {
    zoomReloj = true;
  }
}


void checkHoverReloj() {
  hoverReloj =
    mouseX > reloj5X - reloj5.width/2 &&
    mouseX < reloj5X + reloj5.width/2 &&
    mouseY > reloj5Y - reloj5.height/2 &&
    mouseY < reloj5Y + reloj5.height/2;
}

boolean arenaTerminada() {
  for (int i = 0; i < rows; i++) {
    if (windOffset[i] < width) {
      return false;  // todavía hay arena moviéndose
    }
  }
  return true;  // toda la arena llegó al final
}

  void drawSand() {
  pushStyle();
  rectMode(CORNER);
  noStroke();
  fill(194, 178, 128);

  for (int i = 0; i < rows; i++) {
    if (windOffset[i] >= width) continue;

    float y = i * rowHeight;
    rect(-windOffset[i], y, width, rowHeight + 1);
  }
  popStyle();
 }
}

class DustParticle {
  PVector pos;
  PVector vel;
  float life;
  float size;

  DustParticle(float x, float y, float wind) {
    pos = new PVector(x, y);
    vel = new PVector(
      -wind * 0.9 + random(-0.6, -0.2),
      random(-0.25, 0.25)
    );
    life = 200;
    size = random(2, 4);
}


  void update() {
    pos.add(vel);
    life -= 2;
  }

  void display() {
    noStroke();
    fill(200, 180, 150, life);
    ellipse(pos.x, pos.y, size, size);
  }

  boolean isDead() {
    return life <= 0 || pos.x < -10;
  }
}

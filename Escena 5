class Escena5 {  /* Viejo se ilumina por detras de forma 
gradual y ciclica, como si la luz fuera y viniera, cuando le
das click al viejo, se ilumina de forma constante y te da
instrucciones (escritas o narradas), cuando le das al reloj, 
se disminuye el audio y se hace yun fundido hacia la otra 
escena... TRES RECTS, VIEJO AZUL, MESA MARRON, RELOJ AMARILLO*/

  // Estado
  int estadoEscena5;
  
  // Imagenes   
  // PImage fondo5, viejo, reloj5, mesa5;
 

  // Posiciones
  float viejoX, mesa5X, reloj5X;
  float viejoY, mesa5Y, reloj5Y;

  // Tamaños
  float viejoW, aur5W, mesa5W, reloj5W;
  float viejoH, aur5H, mesa5H, reloj5H;
  
  // Audio
  AudioPlayer audio5, divinidad, dial5;
  
  //TRANSICION INICIO
  int rows = 140;
  float rowHeight;
  float[] windOffset;
  boolean[] activeRow;    // si la fila todavía se mueve y produce partículas

  int currentRow = 0;
  int rowDelay = 3;
  int lastRowFrame = 0;

  float windSpeed = 7;

  boolean windRight = true; // viento izquierda → derecha
  ArrayList<PVector> dust = new ArrayList<PVector>();

  Escena5() {
    
    //Posiciones
  viejoX= width/2;
  mesa5X= width/2; 
  reloj5X= width/2;
  viejoY= height/2+50;
  mesa5Y= height/2+500;
  reloj5Y= height/2+275;
     
    //Tamaños
  viejoW= 500;
  mesa5W= 900;
  reloj5W= 400;
  viejoH= 1000; 
  mesa5H= 700; 
  reloj5H= 200;
  
   //TRANSICION INICIO
    rowHeight = height / float(rows);
    windOffset = new float[rows];
    activeRow = new boolean[rows];

    for (int i = 0; i < rows; i++) {
      windOffset[i] = 0;
      activeRow[i] = false;
    }
    
   activeRow[0] = true; // empezamos desde la primera fila
    
  }
  
  void dibujar(){
    background(200);
    
        
    pushStyle();
    rectMode(CENTER);
    //VIEJO
    fill(0,0,255);
    rect(viejoX, viejoY, viejoW, viejoH);
    
    //MESA
    fill(#986F3C);
    rect(mesa5X, mesa5Y, mesa5W, mesa5H);   
    
    //RELOJ
    fill(255,255,0);
    rect(reloj5X, reloj5Y, reloj5W, reloj5H);
    popStyle();
    
    updateWind();
    updateDust();
    drawSand();
    drawDust();
  }
  
    void updateWind() {

    // Activar filas progresivamente
    if (frameCount - lastRowFrame > rowDelay && currentRow < rows - 1) {
      currentRow++;
      activeRow[currentRow] = true;
      lastRowFrame = frameCount;
    }

    for (int i = 0; i <= currentRow; i++) {
      if (activeRow[i]) {

        // desplazamiento con ruido opcional
        float n = noise(i * 0.08, frameCount * 0.02);
        windOffset[i] += windSpeed * (0.4 + n);

        // Si la fila ya desapareció, la desactivamos
        if (windOffset[i] >= width) {
          windOffset[i] = width;
          activeRow[i] = false; // ya no genera partículas
        }

        // generar polvo solo si la fila sigue activa
        if (activeRow[i] && random(1) < 0.6) {
          float y = i * rowHeight + random(rowHeight);
          float speed = random(4, 8);
          if (!windRight) speed *= -1;
          dust.add(new PVector(-windOffset[i], y, speed));
        }
      }
    }
  }

  void drawSand() {
    noStroke();
    fill(194, 178, 128);

    for (int i = 0; i < rows; i++) {
      if (windOffset[i] >= width) continue;

      float y = i * rowHeight;
      rect(-windOffset[i], y, width, rowHeight + 1);
    }
  }

  void updateDust() {
    for (int i = dust.size() - 1; i >= 0; i--) {
      PVector p = dust.get(i);
      p.x -= p.z;

      // desaparecer al llegar al lado opuesto
      if (windRight) {
        if (p.x > width) dust.remove(i);
      } else {
        if (p.x < 0) dust.remove(i);
      }
    }
  }

  void drawDust() {
    noStroke();
    fill(210, 200, 160, 130);
    for (PVector p : dust) {
      ellipse(p.x, p.y, 2, 2);
    }
  }
}

//LAS PARTICULAS VAN AL REVES

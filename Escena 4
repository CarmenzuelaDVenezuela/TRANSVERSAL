/*Hacer la escena de Aurelio a modo de animacion secuencial,
controlar la transicion de la arena segun x frame*/

class Escena4 {
  
  PImage fondo4, aur;
  
    //ANIMACIÓN
  final int ANIM_FPS = 8;
  final int FRAME_INTERVAL = 1000 / ANIM_FPS;
  int numFrames = 8;
  int currentFrame = 0;
  PImage[] images = new PImage[numFrames]; //394+297
  boolean animPlaying = false;
  boolean animFinished = false;
  int lastFrameTime = 0;

  // ---------------- AGUA ----------------
  float waterLevel;
  float waterSpeed = 1.5;
  float waterAccel = 0.03;
  boolean draining = true;

  // ---------------- TIEMPO ----------------
  int endDrainFrame;
  int delayFrames = 120;

  // ---------------- ARENA ----------------
  boolean sandFalling = false;
  boolean sandFinished = false;

  ArrayList<PVector> grains = new ArrayList<PVector>();

  int cols = 20;
  float[] sandMap = new float[cols];
  float colWidth;

  float sandAccum = 0.25;
  float sandAccel = 0.0008;

  // Avalanchas
  float avalancheThreshold = 12;
  float avalancheSpeed = 0.15;
  
  boolean exitScene = false;
  
   //Audio
  //AudioManager audio4, sonidoAgua2, sonidoArena, caricia;

  // ------------------------------------------------
  Escena4() {
    waterLevel = -200;
    colWidth = width / float(cols);
         
      for (int i = 0; i < numFrames; i++) {
    String imageName = "arena" + nf(i, 4) + ".png";
    images[i] = loadResizedImage(imageName, 1450);
    
     fondo4= loadResizedImage("fondoG.png", width);
     aur= loadResizedImage("aur4.png", 1350);

  }
  
  }

  // ------------------------------------------------
void dibujar() {
  //audio4.loop();
  image(fondo4, width/2, height/2);
  image (aur, width/2-500, height/2+100);

  // 1. Animación (FONDO)
  updateAnimation();
  drawAnimation();

  // 2. Agua (ENCIMA)
  if (draining) {
    //sonidoAgua2.loop();
    waterSpeed += waterAccel;
    waterLevel += waterSpeed;

    if (waterLevel >= height + 200) {
      waterLevel = height + 200;
      draining = false;
      waterSpeed = 0;

      // Arranca animación
      animPlaying = true;
      animFinished = false;
      currentFrame = 0;
      lastFrameTime = millis();
    }
  } //else {sonidoAgua2.stop();}

  drawWater();

  // 3. Arena (cuando termina la animación)
  if (animFinished && !sandFalling && !sandFinished) {
    //sonidoArena.loop();
    sandFalling = true;
  }

  if (sandFalling && !sandFinished) {
    updateSand();
  } //else {sonidoArena.stop();}

  drawSand();
  
  if (exitScene) {
  //println("CAMBIO A ESCENA 5");
  estadoGeneral = ESCENA5;
 }
}


// ================= ANIMACIÓN =================
void updateAnimation() {
  if (!animPlaying || animFinished) return;

  if (millis() - lastFrameTime >= FRAME_INTERVAL) {
    //caricia.play();
    lastFrameTime = millis();
    currentFrame++;

    // Termina SOLO UNA VEZ
    if (currentFrame >= numFrames) {
      currentFrame = numFrames - 1;
      //caricia.stop();
      animFinished = true;
      animPlaying = false;
    }
  }
}

void drawAnimation() {
  imageMode(CENTER);
  image(
    images[currentFrame],
    width / 2-237,
    height / 2
  );
}


  // ------------------------------------------------
  void drawWater() {
    if (draining) {
      noStroke();
      fill(0, 150, 255);

      beginShape();
      for (int x = 0; x <= width; x += 20) {
        float wave = sin(x * 0.03 + frameCount * 0.03) * 18;
        vertex(x, waterLevel + wave);
      }
      vertex(width, height);
      vertex(0, height);
      endShape();
    }
  }

  // ------------------------------------------------
  void drawSand() {
    rectMode(CORNER);
    noStroke();
    fill(194, 178, 128);

    for (int i = 0; i < cols; i++) {
      float h = sandMap[i];
      rect(i * colWidth, height - h, colWidth + 1, h);
    }

    for (PVector g : grains) {
      rect(g.x, g.y, 3, 5);
    }
  }
  
 void updateSand() {
        if (sandFalling && !sandFinished) {

      // Generar granos
      for (int i = 0; i < 20; i++) {
        grains.add(new PVector(
          random(width),
          -10,
          random(-0.6, 0.6)
        ));
      }

      // Movimiento y colisión
      for (int i = grains.size() - 1; i >= 0; i--) {
        PVector g = grains.get(i);

        g.y += 4;
        g.x += g.z;

        int col = int(constrain(g.x / colWidth, 0, cols - 1));
        float localHeight = sandMap[col];

        if (g.y >= height - localHeight) {
          grains.remove(i);
          sandMap[col] += sandAccum;
          sandAccum += sandAccel;
          sandAccum = constrain(sandAccum, 0.25, 1.2);
        }
      }

      // Suavizado
      for (int i = 1; i < cols - 1; i++) {
        float avg = (sandMap[i - 1] + sandMap[i] + sandMap[i + 1]) / 3;
        sandMap[i] = lerp(sandMap[i], avg, 0.02);
      }

      // Avalanchas
      for (int i = 1; i < cols - 1; i++) {
        float diffL = sandMap[i] - sandMap[i - 1];
        float diffR = sandMap[i] - sandMap[i + 1];

        if (diffL > avalancheThreshold) {
          float move = (diffL - avalancheThreshold) * avalancheSpeed;
          sandMap[i] -= move;
          sandMap[i - 1] += move;
        }

        if (diffR > avalancheThreshold) {
          float move = (diffR - avalancheThreshold) * avalancheSpeed;
          sandMap[i] -= move;
          sandMap[i + 1] += move;
        }
      }

      // ¿Pantalla llena?
      float minSand = Float.MAX_VALUE;
      for (float h : sandMap) minSand = min(minSand, h);

      if (minSand >= height) {
        sandFinished = true;
        sandFalling = false;
        grains.clear();
        exitScene = true; // se dispara una sola vez
      }

    }
 
  }
}

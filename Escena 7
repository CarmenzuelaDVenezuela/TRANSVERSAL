class Escena7 {
  
  int estadoEscena7 = JUEGO;
  
  //IMAGENES
  PImage falda, mano, reloj, fondo7, fondo7_2, reloj7;
  
  //AUDIO
  AudioPlayer audio7, fallo, exito, susto, suspense;

  // Tamaño personajes
  int pw = 50;
  int ph = 100;

  // Jugador
  float xBottom;
  float yBottom;

  // Velocidades
  float speedTop = 2;    // enemigos más lentos
  float speedBottom = 8; // jugador más rápido

  // Enemigos infinitos
  ArrayList<Enemy> enemies;
  
  // META
  float metaX, metaY;
  boolean metaActiva = false;

  // Temporizador para spawn
  int tiempoAnterior = 0;
  int intervalo; // variable aleatoria para cada spawn

  // NUEVO: estado interno de interacción
  boolean interactuando = false;
  
  boolean gameOver = false;     // solo para choque con enemigos
  int tiempoGameOver = 0;       // cuando empieza el mensaje
  int duracionGameOver = 4000;  // 4 segundos
  
  boolean suspenseSonando = false;
  
  
  //SEGUNDA PARTE
  
  //falda
  int faldaX, faldaY, faldaW, faldaH;
  
  //reloj
  int relojX, relojY, relojW, relojH;

  //cuerpo
  int cuerpoX, cuerpoY, cuerpoW, cuerpoH;

  
  //mano 
  int manoX, manoY, manoW, manoH;
  // --- interacción mano ---
  boolean manoActiva = false;
  int tiempoMano = 0;
  int duracionMano = 5000; // 5 segundos


  // Constructor
  Escena7() {
    iniciar();
    
    //IMAGENES   
      // fondo7= loadImage("fondo7.png");
      // cuerpo= loadImage("cuerpo.png");
      // reloj7= loadImage("r7.png");
      // mano1= loadImage("mano7_1.png");
      // mano2= loadImage("mano7_2.png");
      
    //AUDIOS
     //audio7 = audioManager.loadFile("esc7.mp3");
     //susto = audioManager.loadFile("eak.mp3");
     //exito = audioManager.loadFile("exito.mp3"); 
     //fallo = audioManager.loadFile("fallo.mp3");
     //exito = audioManager.loadFile("exito.mp3"); 
    
    //SEGUNDA PARTE
    faldaX= width/2-600;
    faldaY= height/2;
    faldaW= 1000;
    faldaH= 1200;
    relojX= width/2-200;
    relojY= height/2 -150;
    relojW= 300;
    relojH= 850;
    manoX= width/2+450;
    manoY= height/2 -100;
    manoW= 800;
    manoH= 750;
    cuerpoX= width/2+650;
    cuerpoY= height/2+50;
    cuerpoW= 500;
    cuerpoH= 1100;

  }

  void iniciar() {
    xBottom = width / 2;
    yBottom = height - ph - 10;

    enemies = new ArrayList<Enemy>();
    tiempoAnterior = millis();
    intervalo = int(random(500, 500)); // primer spawn aleatorio
    interactuando = false; // inicializamos el estado
      // META
  generarMeta();

  }

void dibujar() {
  background(200);
  //audio7.loop();

  switch (estadoEscena7) {

  case JUEGO:
    dibujarJuego();
    break;

  case INTERACCION:
    dibujarInteraccion();
    break;

  case GAME_OVER:
    dibujarGameOver();
    break;
  }
}


  // ===== INPUT TECLADO DENTRO DE LA CLASE =====
  void teclaPulsada() {
    if (estadoEscena7 == JUEGO) {
    if (keyCode == LEFT) {
      xBottom -= speedBottom;
      if (xBottom < 0) xBottom = 0;
    } else if (keyCode == RIGHT) {
      xBottom += speedBottom;
      if (xBottom > width - pw) xBottom = width - pw;
    } else if (keyCode == UP) {
      yBottom -= speedBottom;
      // Ya no hay restricción superior para atravesar el borde
     }
    }
  }

  // Input mouse (puede usarlo más adelante)
void ratonPulsado() {
  if (estadoEscena7 != INTERACCION) return;

  // CLICK EN MANO
  if (mouseX > manoX - manoW/2 && mouseX < manoX + manoW/2 &&
      mouseY > manoY - manoH/2 && mouseY < manoY + manoH/2) {

    manoActiva = true;
    //susto.play();
    tiempoMano = millis();
  }

  // CLICK EN RELOJ → siguiente escena
  if (mouseX > relojX - relojW/2 && mouseX < relojX + relojW/2 &&
      mouseY > relojY - relojH/2 && mouseY < relojY + relojH/2) {
   //suspense.stop();
   //suspenseSonando = false;
    exit();//estadoGeneral = ESCENA8; 
  }
}

void dibujarJuego() {

  // Spawn enemigos
  if (millis() - tiempoAnterior > intervalo) {
    Enemy e = new Enemy();
    e.y = random(0, height - ph);

    if (random(1) < 0.5) {
      e.x = -pw;
      e.direccion = 1;
    } else {
      e.x = width;
      e.direccion = -1;
    }

    enemies.add(e);
    tiempoAnterior = millis();
    intervalo = int(random(200, 500));
  }

  // Enemigos
  for (int i = enemies.size() - 1; i >= 0; i--) {
    Enemy e = enemies.get(i);
    e.update();
    e.display();

    if (colision(e.x, e.y, pw, ph, xBottom, yBottom, pw, ph)) {
      estadoEscena7 = GAME_OVER;
      tiempoGameOver = millis();
    }

    if (e.x < -pw || e.x > width) {
      enemies.remove(i);
    }
  }

  // Jugador
  fill(0, 0, 255);
  rect(xBottom, yBottom, pw, ph);
  
  // META
 if (metaActiva) {
  fill(0, 255, 0);
  rect(metaX, metaY, pw, ph);
 }
 
 if (metaActiva && colision(metaX, metaY, pw, ph, xBottom, yBottom, pw, ph)) {
  //exito.play();
  //audio7.stop();
  metaActiva = false;
  estadoEscena7 = INTERACCION;
 }
}


void dibujarGameOver() {
  background(0);
  //fallo.play();

  if ((millis() / 250) % 2 == 0) {
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(40);
    text("INTÉNTALO OTRA VEZ", width/2, height/2);
  }

  if (millis() - tiempoGameOver > duracionGameOver) {
    //audio7.stop();
    exit();
  }
}

void dibujarInteraccion() {
  background(200);

/*  // --- AUDIO SUSPENSE ---
  if (!suspenseSonando) {
    suspense.loop();
    suspense.setGain(-40); // empieza bajo
    suspenseSonando = true;
  }

  actualizarSuspensePorDistancia();*/

  pushStyle();
  rectMode(CENTER);

  // falda
  fill(255,0,0);
  rect(faldaX, faldaY, faldaW, faldaH);

  // cuerpo
  fill(0,255,0);
  rect(cuerpoX, cuerpoY, cuerpoW, cuerpoH);

  // reloj
  fill(255,255,0);
  rect(relojX, relojY, relojW, relojH);

  // mano
  if (manoActiva && millis() - tiempoMano < duracionMano) {
    fill(255, 0, 255);
  } else {
    manoActiva = false;
    fill(100, 255, 100);
  }
  rect(manoX, manoY, manoW, manoH);

  popStyle();
}

void generarMeta() {
  metaX = random(0, width - pw);
  metaY = 10; // parte superior
  metaActiva = true;
}

/*void actualizarSuspensePorDistancia() {

  // Centro del reloj (rectMode CENTER)
  float cx = relojX;
  float cy = relojY;

  // Usamos el mouse como "cursor de acercamiento"
  float d = dist(mouseX, mouseY, cx, cy);

  // Distancia máxima considerada
  float distanciaMax = 800;
  float distanciaMin = 100;

  // Convertimos distancia a volumen (dB)
  float volumen = map(d, distanciaMax, distanciaMin, -40, 0);
  volumen = constrain(volumen, -40, 0);

  suspense.setGain(volumen);
}*/

  // Colisiones AABB
  boolean colision(float x1, float y1, float w1, float h1,
                   float x2, float y2, float w2, float h2) {
    return x1 < x2 + w2 &&
           x1 + w1 > x2 &&
           y1 < y2 + h2 &&
           y1 + h1 > y2;
  }

  // ===============================
  // CLASE INTERNA ENEMY
 class Enemy {
  float x, y;
  int direccion;     // +1 = derecha, -1 = izquierda
  float speed;       // NUEVO: velocidad individual

  Enemy() {
    speed = random(1, 5); // velocidad aleatoria por enemigo
  }

  void update() {
    x += speed * direccion;
  }

  void display() {
    fill(0);
    rect(x, y, pw, ph);
  }
 }
}

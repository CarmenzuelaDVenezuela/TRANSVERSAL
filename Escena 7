class Escena7 {

  // Tamaño personajes
  int pw = 50;
  int ph = 100;

  // Jugador
  float xBottom;
  float yBottom;

  // Velocidades
  float speedTop = 2;    // enemigos más lentos
  float speedBottom = 8; // jugador más rápido

  // Enemigos infinitos
  ArrayList<Enemy> enemies;

  // Temporizador para spawn
  int tiempoAnterior = 0;
  int intervalo; // variable aleatoria para cada spawn

  // NUEVO: estado interno de interacción
  boolean interactuando = false;
  
  boolean gameOver = false;     // solo para choque con enemigos
  int tiempoGameOver = 0;       // cuando empieza el mensaje
  int duracionGameOver = 4000;  // 4 segundos
  
//sub-es
int rectDerechoW = 250;
int rectDerechoH = 640;

int rectIzquierdoW = 80;
int rectIzquierdoH; // calcularemos para que llegue casi al medio de la pantalla

// MANO
float manitaX, manitaY;
float manitaW = 350;
float manitaH = 350;
float manitaInitialX, manitaInitialY; // posición inicial para reset
int manitaMove = 100;          // píxeles que se desplazará al click
boolean manitaClicked = false; // indica que está en movimiento
int manitaTimer = 0;           // tiempo para reset
int manitaDuration = 300;

// BOTÓN INVISIBLE
float botonX, botonY, botonW, botonH;


  // Constructor
  Escena7() {
    iniciar();
  }

  void iniciar() {
    xBottom = width / 2;
    yBottom = height - ph - 10;

    enemies = new ArrayList<Enemy>();
    tiempoAnterior = millis();
    intervalo = int(random(700, 700)); // primer spawn aleatorio
    interactuando = false; // inicializamos el estado
  }

  void dibujar() {
    background(200);

if (gameOver) {
  background(0);

  // Parpadeo rápido (cada 200 ms)
  if ((millis() / 250) % 2 == 0) {
    fill(255);
    textAlign(CENTER, CENTER);
    textSize(40);
    text("INTÉNTALO OTRA VEZ", width/2, height/2);
  }

  if (millis() - tiempoGameOver > duracionGameOver) {
    estadoGeneral = ESCENA_CREDITOS;
  }
  return;
}

// Sub-escena de interacción
if (interactuando) {
  background(200);

  // Rectángulo derecho: apoyado en borde inferior, no llega al superior
  int derechoX = width - rectDerechoW - 100; // 20 px margen derecho
  int derechoY = height - rectDerechoH;     // apoyado abajo
  fill(150, 50, 50);
  rect(derechoX, derechoY, rectDerechoW, rectDerechoH);

  // Rectángulo izquierdo: casi llega al medio horizontal, ocupa de arriba a abajo
  int izquierdoX = 0;                        // margen izquierdo
  int izquierdoY = 0;
  rectIzquierdoH = height;                     // altura completa
  int izquierdoW = width/2 - 80;              // casi mitad pantalla
  fill(50, 50, 150);
  rect(izquierdoX, izquierdoY, izquierdoW, rectIzquierdoH);
  
  // BOTÓN INVISIBLE: esquina superior derecha del azul
botonW = 70;  // ancho del botón
botonH = 70;  // alto del botón
botonX = izquierdoX + izquierdoW - botonW;  // esquina superior derecha
botonY = izquierdoY;                        // arriba

if (!manitaClicked && manitaInitialX == 0 && manitaInitialY == 0) {
  manitaInitialX = width/2 - manitaW/2 + 200; // un poco a la derecha
  manitaInitialY = height/2 - manitaH/2 + 50;      // vertical centrado
  manitaX = manitaInitialX;
  manitaY = manitaInitialY;
}

// MANita: entre los dos rectángulos
//manitaX = width/2 - manitaW/2 -100;
//manitaY = height/2 - manitaH/2;

//manitaX = manitaInitialX;
//manitaY = manitaInitialY;

fill(255, 200, 0); // color distintivo
rect(manitaX, manitaY, manitaW, manitaH);

// Si MANita está en movimiento por click, regresamos a la posición inicial
if (manitaClicked) {
  if (millis() - manitaTimer > manitaDuration) {
    manitaX = manitaInitialX;
    manitaY = manitaInitialY;
    manitaClicked = false;
  }
}

  return; // no dibujamos enemigos ni jugador mientras estamos en esta sub-escena
}


    // ===============================
    // Comprobar si el jugador salió completamente
    if (yBottom + ph < 0) {
      interactuando = true;
    }

    // ===============================
    // Generación de enemigos aleatoria
    if (millis() - tiempoAnterior > intervalo) {
      Enemy e = new Enemy();
      e.y = random(0, height - ph); // posición vertical aleatoria

      // Aparece a la izquierda o derecha
      if (random(1) < 0.5) {
        e.x = -pw;       // aparece desde la izquierda
        e.direccion = 1; // se mueve hacia la derecha
      } else {
        e.x = width;     // aparece desde la derecha
        e.direccion = -1; // se mueve hacia la izquierda
      }

      enemies.add(e);
      tiempoAnterior = millis();
      intervalo = int(random(900, 1500)); // nuevo intervalo aleatorio
    }
    
    

    // ===============================
    // Actualizar enemigos
    for (int i = enemies.size() - 1; i >= 0; i--) {
      Enemy e = enemies.get(i);
      e.update();
      e.display();

      // Colisión con jugador
      if (colision(e.x, e.y, pw, ph, xBottom, yBottom, pw, ph)) {
         gameOver = true;
          tiempoGameOver = millis();
       }


      // Eliminar enemigos que salieron de la pantalla (lados)
      if (e.x < -pw || e.x > width) {
        enemies.remove(i);
      }
    }

    // ===============================
    // Dibujar jugador
    fill(0, 0, 255);
    rect(xBottom, yBottom, pw, ph);
  }

  // ===== INPUT TECLADO DENTRO DE LA CLASE =====
  void teclaPulsada(char keyChar, int keyCode) {
    if (keyCode == LEFT) {
      xBottom -= speedBottom;
      if (xBottom < 0) xBottom = 0;
    } else if (keyCode == RIGHT) {
      xBottom += speedBottom;
      if (xBottom > width - pw) xBottom = width - pw;
    } else if (keyCode == UP) {
      yBottom -= speedBottom;
      // Ya no hay restricción superior para atravesar el borde
    }
  }

  // Input mouse (puede usarlo más adelante)
  void botonPulsado() {
  if (interactuando) {
    if (mouseX > manitaX && mouseX < manitaX + manitaW &&
        mouseY > manitaY && mouseY < manitaY + manitaH) {
      manitaX += manitaMove;  // se desplaza hacia la derecha
      manitaTimer = millis();
      manitaClicked = true;
    }
    if (mouseX > botonX && mouseX < botonX + botonW &&
    mouseY > botonY && mouseY < botonY + botonH) {
  estadoGeneral = ESCENA8;
}
  }
}



  // Colisiones AABB
  boolean colision(float x1, float y1, float w1, float h1,
                   float x2, float y2, float w2, float h2) {
    return x1 < x2 + w2 &&
           x1 + w1 > x2 &&
           y1 < y2 + h2 &&
           y1 + h1 > y2;
  }

  // ===============================
  // CLASE INTERNA ENEMY
  class Enemy {
    float x, y;
    int direccion; // +1 = va derecha, -1 = va izquierda

    void update() {
      x += speedTop * direccion; // movimiento horizontal
    }

    void display() {
      fill(0);
      rect(x, y, pw, ph);
    }
  }
}

void keyPressed() {
  switch (estadoGeneral) {
    case ESCENA7:
      escena7.teclaPulsada(key, keyCode); // le pasamos el evento a la clase
      break;
  }
}

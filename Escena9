class Escena9 {

  // SUBESTADOS
  final int NORMAL = 0;
  final int ACERCADO = 1;
  int subestado = NORMAL;

  // Posición
  float rectX;

  // Péndulo
  float angulo = 0;
  float velocidad = 0.03;
  float amplitud;
  float largoPendulo = 550;

  // Cristales
  int clickCount = 0;
  final int maxClicks = 4;

  // Zoom progresivo
  float zoomActual = 1.0;
  float zoomTarget = 1.0;
  float zoomSpeed = 0.01;

  // Transición final
  boolean iniciarTransicion = false;
  float tiempoTransicion = 0;
  final float DURACION_TRANSICION = 1000;
  float anguloGlobal = 0;
  float velocidadMaxGiro = PI * 0.5;

  // Imágenes
  PImage fondoBar1, fondoBar2, bar, r9, r10, cristal1, cristal2, cristal3, pendulo;

  Escena9() {
    rectX = width / 2-100;

    // Amplitud segura para que el péndulo no choque con el cristal
    float cristalW = 290;
    amplitud = asin((cristalW/2-200) / largoPendulo);

    // Cargar imágenes redimensionadas previamente
    fondoBar1 = loadResizedImage("fondo9.png", width);
    fondoBar2 = loadResizedImage("fondo10.png", width);
    bar = loadResizedImage("bar.png", 400);
    r9 = loadResizedImage("aur9.png", 600);
    cristal1 = loadResizedImage("esp1.png", 500);
    cristal2 = loadResizedImage("esp2.png", 480);
    cristal3 = loadResizedImage("esp3.png", 490);
    r10 = loadResizedImage("r10.png", 800);
    pendulo = loadResizedImage("pendulo.png", 250);
  }

  void dibujar() {
    run();
  }

void update() {
  if (subestado == ACERCADO) {
    angulo += velocidad;

    if (iniciarTransicion) {
      float t = millis() - tiempoTransicion;
      if (t >= DURACION_TRANSICION) {
        estadoGeneral= ESCENA11;
      }
    }
  }

  // Suaviza el zoom hacia zoomTarget
  zoomActual = lerp(zoomActual, zoomTarget, zoomSpeed);
}

void run() {
  update();

  pushMatrix();

  // Transformación centrada
  float relojX = width / 2;
  float relojY = height / 2;
  translate(relojX, relojY);

  float currentZoom = zoomActual;

  // --- Efecto de transición final con distorsión ---
  if (iniciarTransicion) {
    float t = millis() - tiempoTransicion;
    float factor = constrain(t / DURACION_TRANSICION, 0, 1);

    // distorsión: escala oscilante y rotación
    float scaleX = 1 + factor * 2 + 0.1 * sin(factor * PI * 5); // estira x con oscilación
    float scaleY = 1 + factor * 2 + 0.1 * cos(factor * PI * 5); // estira y con otra oscilación
    float rotateDist = factor * PI * 2 * 0.5; // rotación gradual

    rotate(rotateDist);
    scale(scaleX, scaleY);
  } else {
    scale(currentZoom);
  }

  translate(-relojX, -relojY);

  display();

  popMatrix();
}


  void display() {
    imageMode(CENTER);

    if (subestado == NORMAL) dibujarNormal();
    else dibujarAcercado();
  }

  void dibujarNormal() {
    // Fondo
    image(fondoBar1, width/2, height/2);

    // Rectángulo grande → r9
    image(r9, rectX, height/2);

    // Rectángulo pequeño → bar
    image(bar, rectX + 500, height/2+50);
  }

  void dibujarAcercado() {
  // Fondo
  image(fondoBar2, width/2, height/2);

  // Reloj grande → r10
  float relojX = width / 2;
  float relojY = height / 2 - 100;
  image(r10, relojX, relojY);

  // --- DIBUJAR EL PÉNDULO DETRÁS DEL CRISTAL ---
  pushMatrix();
  float cristalY = relojY + 40;
  float anclajeY = cristalY - 400 / 2 + 30; // 400 = altura del cristal aproximada
  translate(relojX, anclajeY);

  float a = sin(angulo) * amplitud;
  rotate(a);

  // Dibujar pendulo detrás
  imageMode(CENTER);
  image(pendulo, 0, largoPendulo / 2);
  popMatrix();

  // Cristal según clickCount
  PImage cristalImg;
  if (clickCount == 0) cristalImg = cristal1;
  else if (clickCount == 1) cristalImg = cristal2;
  else cristalImg = cristal3;

  // --- Aplicar transparencia ---
  tint(255, 120); // 150 = semitransparente
  image(cristalImg, relojX, cristalY);
  noTint(); // resetear
}


void ratonPulsado() {
  if (subestado == NORMAL && clickEnRectangulo(mouseX, mouseY)) {
    subestado = ACERCADO;

    // --- Iniciar transición de zoom suave ---
    zoomTarget = 1.3;  // zoom deseado para ACERCADO
    // opcional: ajustar velocidad para que sea más rápido
    zoomSpeed = 0.02;
  } 
  else if (clickEnCristal(mouseX, mouseY) && clickCount < maxClicks - 1) {
    clickCount++;
    velocidad += 0.01;
    zoomTarget = 1.0 + 0.2 * clickCount;  // zoom progresivo por clicks
  } 
  else if (clickEnCristal(mouseX, mouseY)) {
    clickCount = maxClicks - 1;
    iniciarTransicion = true;
    tiempoTransicion = millis();
    zoomTarget = 1.0 + 0.2 * clickCount;
  }
}


  boolean clickEnRectangulo(float mx, float my) {
    return (mx > rectX - r9.width / 2 && mx < rectX + r9.width / 2 &&
            my > height/2 - r9.height / 2 && my < height/2 + r9.height / 2);
  }

  boolean clickEnCristal(float mx, float my) {
    float relojX = width / 2;
    float cristalY = height / 2 + 20;
    return (mx > relojX - cristal1.width / 2 && mx < relojX + cristal1.width / 2 &&
            my > cristalY - cristal1.height / 2 && my < cristalY + cristal1.height / 2);
  }
}

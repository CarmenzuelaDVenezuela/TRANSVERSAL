// --- Escena11.pde ---
// Conecta Cuatro + gestión de estados + tiempos + menú empate con botón NO evasivo
// + animación de entrada del tablero y la chica
// + CPU para jugador 2 (verde)

class Escena11 {

  final int FILAS = 6;
  final int COLUMNAS = 7;

  int[][] tablero;
  int turno;
  int estado;        // 0 = juego, 1 = gana J1, 2 = gana J2, 3 = empate
  int subestado;     // 0 = juego, 1 = pausa tablero, 2 = resultado
  boolean entradaCompletada = false; // controla inicio del juego

  float tam = 110;
  float offsetX, offsetY;

  // --- Animación de entrada ---
  float tableroY, tableroTargetY;
  float chicaYAnim, chicaTargetY;

  int tiempoInicio;
  int duracionTablero = 500;
  int duracionVictoria = 5000;
  int duracionDerrota  = 5000;

  boolean mostrarMenuEmpate = false;

  // --- Botón NO ---
  float noX, noY;
  float noXInicial, noYInicial;
  float botonW = 140;
  float botonH = 50;

  PImage tableroImg, chica1, chica2, chica3, chica4, fondo12;

  // --- CPU jugador 2 ---
  int tiempoCPU = 0;
  int retrasoCPU = 800; // ms de espera para que CPU juegue

  Escena11() {
    tablero = new int[FILAS][COLUMNAS];
    turno = 1;
    estado = 0;
    subestado = 0;

    tableroImg = loadResizedImage("tab.png", 500);
    chica1 = loadResizedImage("chica12.png", 1200);
    chica2 = loadResizedImage("beso.png", width);
    chica3 = loadResizedImage("empate.png", 1200);
    chica4 = loadResizedImage("loser.png", width);
    fondo12 = loadResizedImage("fondodeco2.png", width);

    // Posición inicial del botón NO
    noXInicial = width/2 + 100;
    noYInicial = height/2 + 60;
    noX = noXInicial;
    noY = noYInicial;

    // Animación de entrada
    offsetX = width/2;
    offsetY = height/2 + 250;

    tableroTargetY = height/2 + 170;
    tableroY = -500; // empieza fuera de pantalla arriba

    chicaTargetY = height/2; 
    chicaYAnim = height + 500; // empieza desde abajo
  }

  void dibujar() {
    image(fondo12, width/2, height/2);

    // --- Animación de entrada ---
    if (!entradaCompletada) {
        chicaYAnim = lerp(chicaYAnim, chicaTargetY, 0.08);
        image(chica1, width/2, chicaYAnim);

        if (abs(chicaYAnim - chicaTargetY) < 1) {   
            tableroY = lerp(tableroY, tableroTargetY, 0.08);
            image(tableroImg, width/2, tableroY, COLUMNAS * tam + 100, FILAS * tam + 100);

            if (abs(tableroY - tableroTargetY) < 1) {
                entradaCompletada = true;
                subestado = 0; // inicia el juego
                tiempoCPU = millis(); // iniciar temporizador CPU
            }
        }
        return; // no dibujar más hasta terminar animación
    }

    // --- Juego ---
    if (subestado == 0) {
        dibujarTablero();
        if (estado != 0) {
            tiempoInicio = millis();
            subestado = 1;
        }
    } 
    else if (subestado == 1) {
        dibujarTablero();
        if (millis() - tiempoInicio > duracionTablero) {
            tiempoInicio = millis();
            subestado = 2;
        }
    }
    else if (subestado == 2) {
        dibujarTablero();
        dibujarResultado();

        int t = millis() - tiempoInicio;

        if (estado == 1 && t > duracionVictoria) estadoGeneral=ESCENA12;
        if (estado == 2 && t > duracionDerrota)  exit();
    }

    if (estado == 3 && mostrarMenuEmpate) {
        dibujarMenuEmpate();
    }

    // --- CPU turno ---
    if (!entradaCompletada || subestado != 0) return;
    if (estado != 2 && turno == 2) {
        if (millis() - tiempoCPU > retrasoCPU) {
            jugarCPU();
            tiempoCPU = millis();
        }
    }
  }

  void dibujarTablero() {
    // Fondo de la chica según estado
    if (estado == 3) image(chica3, width/2, height/2);
    else image(chica1, width/2, height/2);

    // Dibujar fichas
    for (int f = 0; f < FILAS; f++) {
      for (int c = 0; c < COLUMNAS; c++) {
        float x = offsetX/2 + c * tam + tam/2 + 100;
        float y = offsetY/2 + f * tam + tam/2 - 25;

        if (tablero[f][c] == 1) fill(255, 255, 0); // jugador 1
        else if (tablero[f][c] == 2) fill(0, 255, 0); // CPU
        else continue;
        
        noStroke();
        ellipse(x, y, tam+5, tam+5);
      }
    }

    image(tableroImg, width/2, tableroTargetY, COLUMNAS * tam + 100, FILAS * tam + 100);
  }

  void dibujarResultado() {
    if (estado == 1) image(chica2, width/2, height/2);
    else if (estado == 2) image(chica4, width/2, height/2 + 20);
  }

  void dibujarMenuEmpate() {
    rectMode(CENTER);
    fill(0, 180);
    rect(width/2, height/2, 500, 300, 20);

    fill(255);
    textAlign(CENTER, CENTER);
    textSize(32);
    text("EMPATE", width/2, height/2 - 80);

    textSize(20);
    text("¿Quieres volver a jugar?", width/2, height/2 - 30);

    // Botón SÍ
    fill(100, 200, 100);
    rect(width/2 - 100, height/2 + 60, botonW, botonH, 10);
    fill(0);
    text("SÍ", width/2 - 100, height/2 + 60);

    // Botón NO (evasivo)
    fill(200, 100, 100);
    rect(noX, noY, botonW, botonH, 10);
    fill(0);
    text("NO", noX, noY);
  }

  void ratonPulsado() {
    if (mostrarMenuEmpate) {

      // SÍ
      if (mouseX > width/2 - 170 && mouseX < width/2 - 30 &&
          mouseY > height/2 + 35 && mouseY < height/2 + 85) {
        reiniciarJuego();
        return;
      }

      // NO → se mueve
      if (mouseX > noX - botonW/2 && mouseX < noX + botonW/2 &&
          mouseY > noY - botonH/2 && mouseY < noY + botonH/2) {

        noX = random(100, width - 100);
        noY = random(150, height - 100);
      }
      return;
    }

    if (!entradaCompletada || subestado != 0 || turno == 2) return;

    int col = int((mouseX - offsetX/2 - 80) / tam);
    if (col < 0 || col >= COLUMNAS) return;

    for (int f = FILAS - 1; f >= 0; f--) {
      if (tablero[f][col] == 0) {
        tablero[f][col] = turno;
        comprobarEstado();
        turno = 2; // turno CPU
        tiempoCPU = millis(); // reiniciar temporizador CPU
        break;
      }
    }
  }

  void comprobarEstado() {
    if (hayVictoria(1)) estado = 1;
    else if (hayVictoria(2)) estado = 2;
    else if (tableroLleno()) {
      estado = 3;
      mostrarMenuEmpate = true;
      noX = noXInicial;
      noY = noYInicial;
    }
  }

  boolean tableroLleno() {
    for (int c = 0; c < COLUMNAS; c++) if (tablero[0][c] == 0) return false;
    return true;
  }

  boolean hayVictoria(int j) {
    for (int f = 0; f < FILAS; f++)
      for (int c = 0; c < COLUMNAS - 3; c++)
        if (tablero[f][c] == j && tablero[f][c+1] == j &&
            tablero[f][c+2] == j && tablero[f][c+3] == j) return true;

    for (int c = 0; c < COLUMNAS; c++)
      for (int f = 0; f < FILAS - 3; f++)
        if (tablero[f][c] == j && tablero[f+1][c] == j &&
            tablero[f+2][c] == j && tablero[f+3][c] == j) return true;

    for (int f = 3; f < FILAS; f++)
      for (int c = 0; c < COLUMNAS - 3; c++)
        if (tablero[f][c] == j && tablero[f-1][c+1] == j &&
            tablero[f-2][c+2] == j && tablero[f-3][c+3] == j) return true;

    for (int f = 0; f < FILAS - 3; f++)
      for (int c = 0; c < COLUMNAS - 3; c++)
        if (tablero[f][c] == j && tablero[f+1][c+1] == j &&
            tablero[f+2][c+2] == j && tablero[f+3][c+3] == j) return true;

    return false;
  }

  void reiniciarJuego() {
    tablero = new int[FILAS][COLUMNAS];
    turno = 1;
    estado = 0;
    subestado = 0;
    mostrarMenuEmpate = false;
    noX = noXInicial;
    noY = noYInicial;

    // reiniciar animación de entrada
    tableroY = -500;
    chicaYAnim = height + 500;
    entradaCompletada = false;
  }

  // --- CPU simple: coloca ficha verde al azar en columna válida
  void jugarCPU() {
    ArrayList<Integer> columnasValidas = new ArrayList<Integer>();
    for (int c = 0; c < COLUMNAS; c++) {
      if (tablero[0][c] == 0) columnasValidas.add(c);
    }
    
    if (columnasValidas.size() == 0) return;

    int col = columnasValidas.get(int(random(columnasValidas.size())));

    for (int f = FILAS - 1; f >= 0; f--) {
      if (tablero[f][col] == 0) {
        tablero[f][col] = 2; // CPU
        break;
      }
    }

    comprobarEstado();
    turno = 1; // vuelve al jugador 1
  }
}

// --- Escena11.pde ---
class Escena11 {

  final int FILAS = 6;
  final int COLUMNAS = 7;
  int[][] tablero;
  int turno; 
  int estado; 
  int subestado; 
  float tam;
  float offsetX, offsetY;

  int tiempoInicio = 0;
  int duracionTablero = 500;   
  int duracionImagen = 2500;   

  PVector[] circulosTrans;
  ArrayList<PVector> estela;
  float tamCirculoTrans2;   
  float velocidadTrans2 = 15;

  float posChicaY;
  float chicaYInicial;
  float chicaYArriba = -100;
  boolean noGraciasVisible = true;
  boolean botonesVisibles = false;
  float offsetNoGraciasY = 0;
  float offsetOtraPartidaY = 0;
  
  // --- VARIABLES NUEVAS ---
  float posChicaX;      // posición horizontal de la "chica"
  float chicaXInicial;  // comienza detrás del tablero (centro)
  float chicaXFinal;    // posición final a la derecha del tablero

  Escena11() {
    tablero = new int[FILAS][COLUMNAS];
    turno = 1;
    estado = 0;
    subestado = 0;
    tam = 120;
    posChicaY = 0;

    circulosTrans = new PVector[4];
    estela = new ArrayList<PVector>();
  }

  void inicializar() {
    offsetX = (width - COLUMNAS * tam)/2;
    offsetY = (height - FILAS * tam)/2;
    chicaYInicial = offsetY + FILAS*tam;
    posChicaY = chicaYInicial;

    // La chica empieza detrás del tablero, centrada horizontalmente
    chicaXInicial = offsetX + (COLUMNAS*tam)/2 - (COLUMNAS*tam)/2; // centro del lienzo detrás del tablero
    // Se desliza hacia la derecha, hasta estar al lado derecho del tablero
    chicaXFinal = offsetX + COLUMNAS*tam; 
    posChicaX = chicaXInicial;

    tamCirculoTrans2 = height / 4.0;

    for(int i=0; i<4; i++){
      circulosTrans[i] = new PVector(-tamCirculoTrans2, tamCirculoTrans2*i + tamCirculoTrans2/2);
    }
    estela.clear();
  }

  void dibujar() {
    background(10,10,80);
    for(int i=0;i<width;i+=40) line(i,0,i,height);
    for(int j=0;j<height;j+=40) line(0,j,width,j);

    // --- Chica solo en empate ---
    if(subestado==4){ 
      // Desplazamiento hacia la derecha desde detrás del tablero
      posChicaX = lerp(posChicaX, chicaXFinal, 0.05);
      fill(255,0,255);
      noStroke();
      rect(posChicaX, offsetY, COLUMNAS*tam, FILAS*tam);
    }

    // --- Estados ---
    if(subestado==0){ 
      dibujarTablero();
      if(estado!=0){
        tiempoInicio = millis();
        subestado = 1;
      }
    } 
    else if(subestado==1){
      dibujarTablero(); 
      if(millis() - tiempoInicio >= duracionTablero){
        tiempoInicio = millis();
        subestado = 2; 
      }
    } 
    else if(subestado==2){ 
      if(estado==1) fill(0,255,0);
      else if(estado==2) fill(255,0,0);
      rect(0,0,width,height);

      if(millis()-tiempoInicio >= duracionImagen){
        if(estado==1){ subestado=3; tiempoInicio=millis(); } 
        else if(estado==2){ exit(); }
      }
    } 
    else if(subestado==3){
      dibujarTransicion();
    } 
    else if(subestado==4){
      posChicaY = lerp(posChicaY,chicaYArriba,0.05);
      dibujarTablero();
      if(!botonesVisibles && millis()-tiempoInicio >= duracionTablero) botonesVisibles=true;
      if(botonesVisibles) mostrarOpcionesEmpate();
    }
  }

  void dibujarTablero(){
    fill(0,0,200); noStroke();
    rect(offsetX,offsetY,COLUMNAS*tam,FILAS*tam);
    for(int f=0;f<FILAS;f++){
      for(int c=0;c<COLUMNAS;c++){
        float x=offsetX+c*tam+tam/2;
        float y=offsetY+f*tam+tam/2;
        fill(0); ellipse(x,y,tam*0.8,tam*0.8);
        if(tablero[f][c]==1){ fill(255,0,0); ellipse(x,y,tam*0.8,tam*0.8); }
        if(tablero[f][c]==2){ fill(255,255,0); ellipse(x,y,tam*0.8,tam*0.8); }
      }
    }
  }

  void ratonPulsado(){
    if(subestado>=2 && subestado!=4) return;
    if(subestado==4 && botonesVisibles){
      if(noGraciasVisible && mouseX>width/2-150 && mouseX<width/2-10 && mouseY>height-100 && mouseY<height-50){ 
        noGraciasVisible=false; return; 
      }
      if(mouseX>width/2+20 && mouseX<width/2+200 && mouseY>height-100 && mouseY<height-50){ 
        reiniciarJuego(); return; 
      }
    }
    int col=int((mouseX-offsetX)/tam);
    if(col<0||col>=COLUMNAS) return;
    for(int f=FILAS-1;f>=0;f--){
      if(tablero[f][col]==0){
        tablero[f][col]=turno;
        comprobarEstado();
        turno=(turno==1)?2:1;
        break;
      }
    }
  }

  void comprobarEstado(){
    if(hayVictoria(1)) estado=1;
    else if(hayVictoria(2)) estado=2;
    else if(tableroLleno()) estado=3;
  }

  boolean tableroLleno(){
    for(int c=0;c<COLUMNAS;c++){
      if(tablero[0][c]==0) return false;
    }
    return true;
  }

  boolean hayVictoria(int jugador){
    for(int f=0;f<FILAS;f++)
      for(int c=0;c<COLUMNAS-3;c++)
        if(tablero[f][c]==jugador && tablero[f][c+1]==jugador && tablero[f][c+2]==jugador && tablero[f][c+3]==jugador) return true;
    for(int c=0;c<COLUMNAS;c++)
      for(int f=0;f<FILAS-3;f++)
        if(tablero[f][c]==jugador && tablero[f+1][c]==jugador && tablero[f+2][c]==jugador && tablero[f+3][c]==jugador) return true;
    for(int f=3;f<FILAS;f++)
      for(int c=0;c<COLUMNAS-3;c++)
        if(tablero[f][c]==jugador && tablero[f-1][c+1]==jugador && tablero[f-2][c+2]==jugador && tablero[f-3][c+3]==jugador) return true;
    for(int f=0;f<FILAS-3;f++)
      for(int c=0;c<COLUMNAS-3;c++)
        if(tablero[f][c]==jugador && tablero[f+1][c+1]==jugador && tablero[f+2][c+2]==jugador && tablero[f+3][c+3]==jugador) return true;
    return false;
  }

  /*void probarEmpate(){
    for(int f=0; f<FILAS; f++){
      for(int c=0; c<COLUMNAS; c++){
        tablero[f][c] = (f+c)%2 + 1;
      }
    }
    
    estado = 3;
    subestado = 4;
    tiempoInicio = millis();
    botonesVisibles = false;
  }*/

  void dibujarTransicion(){
    for(PVector pos : estela){
      pushMatrix();
      translate(pos.x, pos.y);
      float ang = frameCount * 0.05;
      rotate(ang);
      fill(255, 255, 0, 100);
      noStroke();
      ellipse(0, 0, tamCirculoTrans2, tamCirculoTrans2);
      popMatrix();
    }

    for(int i=0; i<circulosTrans.length; i++){
      PVector c = circulosTrans[i];
      pushMatrix();
      translate(c.x, c.y);
      float ang = frameCount * 0.1 * (i+1);
      rotate(ang);
      fill(255, 255, 0);
      noStroke();
      ellipse(0, 0, tamCirculoTrans2, tamCirculoTrans2);
      popMatrix();
    }

    for(PVector c : circulosTrans){
      c.x += velocidadTrans2;
      estela.add(c.copy());
    }

    if(estela.size() > 300) estela.remove(0);

    if(circulosTrans[0].x - tamCirculoTrans2/2 > width){
      estadoGeneral = ESCENA12;
    }
  }

  void mostrarOpcionesEmpate(){
    textAlign(CENTER,CENTER); textSize(30);
    float targetNoGraciasY=0;
    if(noGraciasVisible && mouseX>width/2-150 && mouseX<width/2-10 && mouseY>height-100 && mouseY<height-50) targetNoGraciasY=-10;
    offsetNoGraciasY = lerp(offsetNoGraciasY,targetNoGraciasY,0.2);
    if(noGraciasVisible){ fill(255); rect(width/2-150,height-100+offsetNoGraciasY,140,50); fill(0); text("No, gracias",width/2-80,height-75+offsetNoGraciasY); }

    float targetOtraPartidaY=0;
    if(mouseX>width/2+20 && mouseX<width/2+200 && mouseY>height-100 && mouseY<height-50) targetOtraPartidaY=-10;
    offsetOtraPartidaY = lerp(offsetOtraPartidaY,targetOtraPartidaY,0.2);
    fill(255); rect(width/2+20,height-100+offsetOtraPartidaY,180,50); fill(0); text("Otra partida",width/2+110,height-75+offsetOtraPartidaY);
  }

  void reiniciarJuego(){
    tablero = new int[FILAS][COLUMNAS];
    turno=1; estado=0; subestado=0;
    posChicaY = chicaYInicial;
    posChicaX = chicaXInicial;
    noGraciasVisible=true; botonesVisibles=false;

    for(int i=0; i<4; i++){
      circulosTrans[i].x = -tamCirculoTrans2;
      circulosTrans[i].y = tamCirculoTrans2*i + tamCirculoTrans2/2;
    }
    estela.clear();
  }
}

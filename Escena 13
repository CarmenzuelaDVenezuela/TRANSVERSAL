float ease(float current, float target, float speed) {
  return current + (target - current) * speed;
}

class Escena13 {

  int estado;

  PImage r14, time14, fondofinal;

  // -------------------------
  // PERSONAJE PRINCIPAL (ROJO) ANIMADO
  // -------------------------
  float pX, pY;
  float pW = 140;
  float pH = 340;

  Animation rojoAnim;      // animación del personaje
  boolean animTerminada = false; // indica si se llegó al último frame

  float pXInicial;         // posición inicial X del sprite
  float pXObjetivo;        // posición final X del sprite

  // -------------------------
  // PERSONAJE TIEMPO (AZUL)
  // -------------------------
  float tX, tY;

  // -------------------------
  // SUELO Y CÁMARA
  // -------------------------
  float sueloY;
  float camX = 0;
  float camY = 0;
  float camZoom = 1.0;
  float camZoomObj = 1.0;

  // -------------------------
  // CONTROL ZOOM Y TIEMPO
  // -------------------------
  boolean zoomActivo = false;
  float tiempoEstado = 0;

  // -------------------------
  // TRANSICIÓN / INICIO ESCENA
  // -------------------------
  float rX, rY;
  boolean escenaActiva = false;

  Escena13() {

    // La escena NO empieza aún
    estado = E13_PREPARACION;

    sueloY = height/2 + 280;

    // Posición inicial y final del sprite rojo
    pXInicial = -110;              // empieza fuera de la pantalla a la izquierda
    pXObjetivo = width/2 - 650;    // posición final
    pX = pXInicial;
    pY = sueloY - 150;

    tX = width + 300;
    tY = sueloY - 520/2;

    r14 = loadResizedImage("r14.png", width);
    time14 = loadResizedImage("time14.png", 400);
    fondofinal = loadResizedImage("fondofinal.png", width);

    // Reloj completamente fuera por la derecha
    rX = width + r14.width / 2;
    rY = height / 2;

    // -------------------------
    // CARGAR ANIMACIÓN DEL PERSONAJE ROJO
    // -------------------------
    rojoAnim = new Animation("aurcae", 6, 8); // archivos aurcae0000.png ... 0005
  }

  // -------------------------
  // DIBUJAR
  // -------------------------
  void dibujar() {
    rectMode(CENTER);

    if (estado == E13_FINAL) {
      background(0);
      actualizar();
      return;
    }

    pushMatrix();

    // --- CÁMARA (AFECTA A TODO) ---
    translate(width/2, height/2);
    scale(camZoom);
    translate(-width/2 + camX, -height/2 + camY);

    // Fondo
    imageMode(CORNER);
    image(fondofinal, 0, 0);

    // -------- ROJO ANIMADO --------
    rojoAnim.display(pX - pW/2, pY - pH/2, animTerminada);

    // -------- AZUL --------
    if (estado >= E13_ENTRADA_TIEMPO) {
      imageMode(CENTER);
      image(time14, tX, tY);
    }

    // -------- RELOJ (MISMA CÁMARA) --------
    imageMode(CENTER);
    image(r14, rX, rY);

    popMatrix();

    actualizar();
  }

  // -------------------------
  // ACTUALIZAR
  // -------------------------
  void actualizar() {

    // -------- TRANSICIÓN DEL RELOJ --------
    if (!escenaActiva) {

      float objetivoX = -width / 3; // deja media imagen visible
      rX = ease(rX, objetivoX, 0.05);

      if (abs(rX - objetivoX) < 2) {
        rX = objetivoX;
        escenaActiva = true;      // AHORA empieza la escena
        tiempoEstado = millis(); // reset de tiempo narrativo
      }

      camZoom = ease(camZoom, camZoomObj, 0.05);
      return;
    }

    // -------- LÓGICA NORMAL DE ESCENA --------
    switch (estado) {

      case E13_PREPARACION:
        estado = E13_CAIDA_PRINCIPAL;
        break;

      case E13_CAIDA_PRINCIPAL:
        // Solo reproducir animación, posición se mueve linealmente en X
        if (!animTerminada) {
          rojoAnim.update();

          // Movimiento lineal X desde pXInicial a pXObjetivo según progreso de frames
          float t = (float)rojoAnim.currentFrame / (rojoAnim.imageCount - 1); // 0..1
          pX = lerp(pXInicial, pXObjetivo, t);

        } else {
          pX = pXObjetivo; // asegurar posición final
          estado = E13_ENTRADA_TIEMPO;
          tiempoEstado = millis();
        }
        break;

      case E13_ENTRADA_TIEMPO:
        tX = ease(tX, width/2 + 300, 0.005);

        if (!zoomActivo && abs(tX - (width/2 + 300)) < 3) {
          zoomActivo = true;
          tiempoEstado = millis();
        }

        if (zoomActivo && millis() - tiempoEstado >= 5000) {
          camZoomObj = 1.4;
          camX = ease(camX, width/2 - tX, 0.05);
          camY = ease(camY, height/2 - tY, 0.05);

          if (millis() - tiempoEstado >= 10000) {
            estado = E13_ZOOM_ROJO;
            tiempoEstado = millis();
          }
        }
        break;

      case E13_ZOOM_ROJO:
        camZoomObj = 1.4;
        camX = ease(camX, width/2 - pX, 0.05);
        camY = ease(camY, height/2 - pY, 0.05);

        if (millis() - tiempoEstado >= 5000) {
          estado = E13_PLANO_GENERAL;
          tiempoEstado = millis();
        }
        break;

      case E13_PLANO_GENERAL:
        camZoomObj = 1.0;
        camX = ease(camX, 0, 0.05);
        camY = ease(camY, 0, 0.05);

        if (millis() - tiempoEstado >= 5000) {
          estado = E13_FINAL;
          tiempoEstado = millis();
        }
        break;

      case E13_FINAL:
        background(0);
        if (millis() - tiempoEstado >= 500) {
          estadoGeneral=ESCENACREDITOS;
        }
        break;
    }

    camZoom = ease(camZoom, camZoomObj, 0.05);
  }

  // ================== CLASE ANIMACIÓN ==================
  class Animation {
    PImage[] images;
    int imageCount;
    int currentFrame = 0;
    int frameDelay;
    int lastUpdate;

    Animation(String prefix, int count, int fps) {
      imageCount = count;
      images = new PImage[imageCount];
      for (int i = 0; i < count; i++) {
        String filename = prefix + nf(i, 4) + ".png"; // aurcae0000.png ... 0005
        images[i] = loadResizedImage(filename, 500);
      }
      frameDelay = 1000 / fps;
      lastUpdate = millis();
    }

    void update() {
      if (!animTerminada) { // solo avanza si la animación no terminó
        int now = millis();
        if (now - lastUpdate >= frameDelay) {
          currentFrame++;
          if (currentFrame >= imageCount - 1) {
            currentFrame = imageCount - 1; // detener en el último frame
            animTerminada = true;         // marca como terminada
          }
          lastUpdate = now;
        }
      }
    }

    void display(float x, float y, boolean animDetenida) { 
    imageMode(CORNER); 
    // Calculamos el desplazamiento según el índice del frame 
      float dx = currentFrame * 20; // 3 píxeles a la derecha por frame 
      float dy = currentFrame * 30; // 3 píxeles hacia abajo por frame 
    image(images[currentFrame], x + dx, y + dy); 
  } 
 } 
}
